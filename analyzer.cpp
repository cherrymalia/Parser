#include "analyzer.h"

using namespace std;

vector<string> tokens;

bool isVariable(const string &str) {
    for (int counter = 0; counter < str.size(); counter++) {
        if (!(isalpha(str[counter]))) {
            return false;
        }
    }
    return true;
}

bool isKeyword(const string &str) {
    string keyword = "float";
    if (keyword == str) {
        return true;
    }
    return false;
}

bool isOperator(const string &str) {
    const vector<string> operators{"*", "+", "-", "/", "="};
    
    for (const auto &op : operators)
        if (op == str) {
            return true;
        }
    return false;
}

string getOperator(const string &str) {
    const vector<string> operators{"*", "+", "-", "/", "="};
    
    if (str == operators[0]) {
        return "multiply_op";
    } else if (str == operators[1]) {
        return "app_op";
    } else if (str == operators[2]) {
        return "subtract_op";
    } else if (str == operators[3]) {
        return "divide_op";
    } else if (str == operators[4]) {
        return "assignment_op";
    } else {
        return "not an operator";
    }
}

//add block to name each lexeme with different token type ("(" = right_paren, ")" = left_paren, etc.)
bool isSeparator(const string &str) {
    const vector<string> separators{"{", "}", ",", "(", ")", ";"};
    for (const auto &separate : separators) {
        if (separate == str) {
            return true;
        }
    }
    return false;
}

string getSeparator(const string &str) {
    const vector<string> separators{"{", "}", ",", "(", ")", ";"};
    if (str == separators[0]) {
        return "left_brace";
    } else if (str == separators[1]) {
        return "right_brace";
    } else if (str == separators[2]) {
        return "comma";
    } else if (str == separators[3]) {
        return "left_paren";
    } else if (str == separators[4]) {
        return "right_paren";
    } else if (str == separators[5]) {
        return "semicolon";
    } else {
        return "not a separator";
    }
}

bool isNotLegal(const string &str) {
    return str == " " || str == "\n";
}

//prints the lexeme and token type in a table format
void printRoleOfToken(const string &token) {
    if (isOperator(token)) {
        tokens.emplace_back(getOperator(token));
        cout << token << "                  " << getOperator(token) << "\n";
    } else if (isSeparator(token)) {
        tokens.emplace_back(getSeparator(token));
        cout << token << "                  " << getSeparator(token) << "\n";
    } else if (isKeyword(token)) {
        tokens.emplace_back("keyword");
        cout << token << "              keyword\n";
    } else if (isVariable(token)) {
        tokens.emplace_back("variable");
        cout << token << "                  variable\n";
    } else {
        throw runtime_error("Invalid token: " + token);
    }
}

//lexical analyzer
void lexicalAnalyze(const string &nameOfFile) {
    char ch;
    string buffer;
    fstream file(nameOfFile, fstream::in);

    if (!file.is_open()) {
        cout << "error while opening the file\n";
        exit(0);
    }

    cout <<"\nLexeme              Token" << endl;
    cout <<"-------------------------------" << endl;
    while (file >> noskipws >> ch) {
        if (isNotLegal(string(1, ch))) {
            if (!buffer.empty()) {
                printRoleOfToken(buffer);
                buffer = "";
            }
            continue;
        }

        if (isOperator(string(1, ch)) && !isOperator(buffer)){
            if (!buffer.empty()) {
                printRoleOfToken(buffer);
                buffer = "";
            }
        }

        if (!isOperator(string(1, ch)) && isOperator(buffer)) {
            printRoleOfToken(buffer);
            buffer = "";
        }

        if (isSeparator(string(1, ch))) {
            if (!buffer.empty()) {
                printRoleOfToken(buffer);
                buffer = "";
            }
            if (isSeparator(string(1, ch))) {
                printRoleOfToken(string(1, ch));
                continue;
            }
        }
        buffer += ch;
    }

    file.close();

    if(isProgram(tokens)) {
        cout << "This is a valid program" << endl;
    } else {
        cout << "This is not a valid program" << endl;
    }
}

//check if the program is syntactically correct
bool isProgram(vector<string> &list) {
    if (list[0] == "keyword") {
        for (int i = 0; i < list.size(); i++) {
        
        }
    } else {
        cout << "The program cannot be generated by the Demo Language" << endl;
        cout << "Error: Program must start with a keyword" << endl;
        return false;
    }

    cout << "The program is generated by the grammar" << endl;
    return true;
}